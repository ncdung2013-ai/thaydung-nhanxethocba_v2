<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tr·ª£ l√Ω Nh·∫≠n x√©t H·ªçc b·∫° (All-in-One)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- C·∫•u h√¨nh Tailwind -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: { sans: ['Inter', 'sans-serif'] },
            colors: { primary: '#0F52BA', secondary: '#E1E8F0' },
            animation: { 
                'spin-slow': 'spin 3s linear infinite',
                'fade-in': 'fadeIn 0.3s ease-out',
                'fade-in-up': 'fadeInUp 0.5s ease-out'
            },
            keyframes: {
                fadeIn: {
                    '0%': { opacity: '0' },
                    '100%': { opacity: '1' },
                },
                fadeInUp: {
                    '0%': { opacity: '0', transform: 'translateY(20px)' },
                    '100%': { opacity: '1', transform: 'translateY(0)' },
                }
            }
          }
        }
      }
    </script>
    
    <style>
        body { background-color: #f8fafc; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .cursor-wait { cursor: wait; }
    </style>

    <!-- Import Map: ƒê·ªãnh nghƒ©a n∆°i t·∫£i c√°c th∆∞ vi·ªán -->


    <!-- Babel Standalone: ƒê·ªÉ tr√¨nh duy·ªát hi·ªÉu ƒë∆∞·ª£c code React (JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-50 text-slate-900 antialiased">
    <div id="root"></div>

    <!-- MAIN SCRIPT: CH·ª®A TO√ÄN B·ªò LOGIC -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "@google/genai": "https://esm.sh/@google/genai@0.1.1",
    "xlsx": "https://esm.sh/xlsx@0.18.5",
    "html2canvas": "https://esm.sh/html2canvas@1.4.1",
    "jspdf": "https://esm.sh/jspdf@2.5.1",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "path": "https://esm.sh/path@^0.12.7",
    "vite": "https://esm.sh/vite@^7.3.1",
    "@vitejs/plugin-react": "https://esm.sh/@vitejs/plugin-react@^5.1.2"
  }
}
</script>
    <script type="text/babel" data-type="module" data-presets="typescript,react">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';
        import { GoogleGenAI, Type } from '@google/genai';
        import * as XLSX from 'xlsx';
        import html2canvas from 'html2canvas';
        import { jsPDF } from 'jspdf';

        // --- 1. TYPES & ENUMS ---
        enum TeacherRole {
            SUBJECT = 'GVBM',
            HOMEROOM = 'GVCN',
        }

        // --- 2. SERVICES ---

        // --- EXCEL SERVICE ---
        const isNamePart = (val) => {
            if (typeof val !== 'string') return false;
            const str = val.trim();
            if (str.length === 0) return false;
            if (/\d/.test(str)) return false; 
            if (str.length < 2 && str.toUpperCase() !== '√ù') return false;
            const keywords = [
                'stt', 'h·ªç', 't√™n', 'th·ª©', 'ng√†y', 'th√°ng', 'nƒÉm', 'l·ªõp', 'tr∆∞·ªùng', 
                'd√¢n', 't·ªôc', 'n·ªØ', 'nam', 'ƒëi·ªÉm', 'trung', 'b√¨nh', 'x·∫øp', 'lo·∫°i',
                'ghi', 'ch√∫', 'k·∫øt', 'qu·∫£', 'h·ªçc', 'k·ª≥', 'm√¥n', 
                'gdcd', 'c√¥ng', 'ngh·ªá', 'tin', 'th·ªÉ',
                'gi√°o', 'vi√™n', 'ng∆∞·ªùi', 'l·∫≠p', 'bi·ªÉu', 'th·ªëng', 'k√™',
                'tbm', 'ƒëtb', 'hk1', 'hk2', 'cn', 't·ªët', 'kh√°',
                'ubnd', 'thcs', 'thpt', 'ti·ªÉu', 'ph√≤ng', 's·ªü', 'ƒë√†o', 't·∫°o', 'c·ªông', 'h√≤a',
                'x√£', 'huy·ªán', 't·ªânh', 'th√†nh', 'ph·ªë', 'ƒë·ªôc', 'l·∫≠p', 't·ª±', 'do',
                'ƒëƒëg', 'tx', 'ƒëgtx', 'ƒëƒëgc', 'nh·∫≠n', 'x√©t', 'kh·ªëi',
                's·ªë', 'l∆∞·ª£ng', 't·ªâ', 'l·ªá', 't·ª∑', 'ph·∫ßn', 'trƒÉm', 't·ªïng',
                'sinh', 'ƒë·∫°t', 'ch∆∞a' 
            ];
            const lower = str.toLowerCase();
            if (['stt', 'ƒëƒëgtx', 'ƒëƒëgck', 'ƒëtbmhk'].some(k => lower === k)) return false;
            if (lower.includes('s·ªë l∆∞·ª£ng') || lower.includes('t·ªâ l·ªá') || lower.includes('t·ª∑ l·ªá') || lower.includes('th·ªëng k√™')) return false;
            if (lower.includes('s·ªë h·ªçc sinh') || lower === 'ƒë·∫°t' || lower === 'ch∆∞a ƒë·∫°t') return false;
            if (keywords.some(k => lower === k)) return false; 
            if (['tr∆∞·ªùng', 'ph√≤ng', '·ªßy', 'ban', 'c·ªông h√≤a'].some(k => lower.includes(k))) return false;
            if (/^(T|K|TB|Y|G|ƒê|Cƒê|TX\d|HK\d)$/.test(str.toUpperCase())) return false;
            return true;
        };

        const detectSubject = (headers) => {
            const flatHeaders = headers.flat().join(' ').toLowerCase();
            if (flatHeaders.includes('to√°n')) return 'To√°n';
            if (flatHeaders.includes('vƒÉn') || flatHeaders.includes('vi·ªát') || flatHeaders.includes('ng·ªØ')) return 'VƒÉn';
            if (flatHeaders.includes('l·ªãch s·ª≠') || flatHeaders.includes('ƒë·ªãa l√Ω') || flatHeaders.includes('s·ª≠') || flatHeaders.includes('ƒë·ªãa')) return 'LS & ƒêL';
            if (flatHeaders.includes('khoa h·ªçc t·ª± nhi√™n') || flatHeaders.includes('khtn') || flatHeaders.includes('l√Ω') || flatHeaders.includes('h√≥a') || flatHeaders.includes('sinh') || flatHeaders.includes('v·∫≠t')) return 'KHTN';
            if (flatHeaders.includes('tin')) return 'Tin h·ªçc';
            if (flatHeaders.includes('anh') || flatHeaders.includes('ngo·∫°i ng·ªØ')) return 'Ng.ng·ªØ';
            if (flatHeaders.includes('gdcd') || flatHeaders.includes('c√¥ng d√¢n')) return 'GDCD';
            if (flatHeaders.includes('c√¥ng ngh·ªá')) return 'C.ngh·ªá';
            if (flatHeaders.includes('th·ªÉ') || flatHeaders.includes('gdtc')) return 'GDTC';
            if (flatHeaders.includes('nh·∫°c') || flatHeaders.includes('m·ªπ thu·∫≠t') || flatHeaders.includes('ngh·ªá thu·∫≠t')) return 'Ngh·ªá thu·∫≠t';
            if (flatHeaders.includes('ƒë·ªãa ph∆∞∆°ng') || flatHeaders.includes('ndgdcƒëp')) return 'NDGDCƒêP';
            if (flatHeaders.includes('tr·∫£i nghi·ªám') || flatHeaders.includes('h∆∞·ªõng nghi·ªáp') || flatHeaders.includes('hƒëtn')) return 'HƒêTN&HN';
            return undefined;
        };

        const parseExcelData = (fileData, role) => {
            try {
                let workbook = (typeof fileData === 'string') 
                ? XLSX.read(fileData, { type: 'string' }) 
                : XLSX.read(fileData, { type: 'array' });

                if (!workbook.SheetNames || workbook.SheetNames.length === 0) return { students: [] };
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                if (!worksheet) return { students: [] };
                
                const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                if (!rawData || rawData.length === 0) return { students: [] };

                const headerRows = rawData.slice(0, 5);
                const detectedSubject = detectSubject(headerRows);
                const students = [];

                rawData.forEach((row, rowIndex) => {
                    if (!Array.isArray(row) || row.length === 0) return;
                    let hasIndex = false;
                    const firstCell = row[0];
                    if (typeof firstCell === 'number' || (typeof firstCell === 'string' && /^\d+$/.test(firstCell.trim()))) {
                        const val = Number(firstCell);
                        if (val > 0 && val < 1000) hasIndex = true;
                    }

                    let nameParts = [];
                    let nameEndIndex = -1; 

                    for (let i = 0; i < row.length; i++) {
                        const cell = row[i];
                        if (nameParts.length === 0 && (typeof cell === 'number' || (typeof cell === 'string' && /^\d+$/.test(cell.trim())))) continue;
                        if (nameParts.length === 0) {
                            if (isNamePart(cell)) {
                                nameParts.push(String(cell).trim());
                                nameEndIndex = i;
                            }
                        } else {
                            if (isNamePart(cell)) {
                                nameParts.push(String(cell).trim());
                                nameEndIndex = i;
                            } else if (cell === undefined || cell === null || String(cell).trim() === '') {
                                const nextCell = row[i+1];
                                if (isNamePart(nextCell)) continue; else break; 
                            } else {
                                break;
                            }
                        }
                    }

                    const fullName = nameParts.join(' ').trim();
                    if (!fullName || fullName.length < 2) if (fullName !== '√ù') return;

                    const upperName = fullName.toUpperCase();
                    if (upperName.includes("TR∆Ø·ªúNG") || upperName.includes("THCS") || upperName.includes("UBND") || upperName.includes("C·ªòNG H√íA")) return;
                    if (upperName.includes("S·ªê L∆Ø·ª¢NG") || upperName.includes("T·ªà L·ªÜ") || upperName.includes("T·ªîNG C·ªòNG") || upperName.startsWith("S·ªê H·ªåC SINH")) return;
                    if (fullName.includes("%") || (fullName.includes("-") && fullName.length > 5 && !fullName.includes(" "))) return;
                    
                    let subjectScore, subjectRating, academicResult, conductRating, absences;

                    if (role === TeacherRole.SUBJECT) {
                        for (let j = row.length - 1; j > nameEndIndex; j--) {
                            const cell = row[j];
                            if (cell === undefined || cell === null || String(cell).trim() === '') continue;
                            const cellStr = String(cell).trim().replace(',', '.');
                            const cellNum = parseFloat(cellStr);
                            if (!isNaN(cellNum)) {
                                if (cellNum >= 0 && cellNum <= 10) { subjectScore = cellNum; break; }
                            } else {
                                const upper = cellStr.toUpperCase();
                                if (/^(T|K|ƒê|Cƒê|TB|G|Y|ƒê·∫†T|CH∆ØA ƒê·∫†T)$/.test(upper)) { subjectRating = upper; break; }
                            }
                        }
                    } else {
                        const ratingsFound = [];
                        for (let j = nameEndIndex + 1; j < row.length; j++) {
                            const cell = row[j];
                            if (cell === undefined || cell === null || String(cell).trim() === '') continue;
                            const str = String(cell).trim();
                            const upper = str.toUpperCase();
                            if (/^(T|K|ƒê|Cƒê|G|TB|Y|T·ªêT|KH√Å|ƒê·∫†T|CH∆ØA ƒê·∫†T|GI·ªéI|Y·∫æU|TRUNG B√åNH|K√âM)$/.test(upper)) {
                                ratingsFound.push(upper);
                                continue;
                            }
                            if (/^\d+$/.test(str)) {
                                const n = parseInt(str, 10);
                                if (n >= 0 && n < 60) absences = n; 
                            }
                        }
                        if (ratingsFound.length >= 2) {
                            academicResult = ratingsFound[0];
                            conductRating = ratingsFound[1];
                        } else if (ratingsFound.length === 1) {
                            academicResult = ratingsFound[0];
                        }
                    }

                    const hasData = (role === TeacherRole.SUBJECT) 
                        ? (subjectScore !== undefined || subjectRating !== undefined)
                        : (academicResult !== undefined || conductRating !== undefined || absences !== undefined);

                    if (!hasIndex && !hasData) return;

                    students.push({
                        id: `student-xls-${Date.now()}-${rowIndex}`,
                        name: fullName,
                        comment: '',
                        isProcessing: false,
                        subjectScore,
                        subjectRating,
                        academicResult,
                        conductRating,
                        absences
                    });
                });
                return { students, detectedSubject };
            } catch (e) {
                console.error("Excel Parsing Error:", e);
                return { students: [] };
            }
        };

        // --- GEMINI SERVICE ---
        const getStoredKey = () => localStorage.getItem('GEMINI_API_KEY') || "";
        const getAIClient = (key) => {
            const apiKey = key || getStoredKey();
            if (!apiKey) throw new Error("MISSING_API_KEY");
            return new GoogleGenAI({ apiKey });
        };

        const CANDIDATE_MODELS = [
            "gemini-2.0-flash",
            "gemini-2.0-flash-lite-preview-02-05", 
            "gemini-1.5-flash", 
            "gemini-flash-latest"
        ];
        
        const getActiveModel = () => localStorage.getItem('GEMINI_ACTIVE_MODEL') || CANDIDATE_MODELS[0];

        const callWithRetry = async (fn, retries = 3, baseDelay = 3000) => {
            for (let i = 0; i < retries; i++) {
                try { return await fn(); } catch (error) {
                    const msg = error.message || "";
                    const isTransient = msg.includes("429") || msg.includes("503") || msg.includes("overloaded") || msg.includes("quota");
                    if (!isTransient || i === retries - 1) throw error;
                    const waitTime = baseDelay * (i + 1);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
        };

        const testApiConnection = async (apiKey) => {
            const ai = new GoogleGenAI({ apiKey });
            let lastError = null;
            for (const model of CANDIDATE_MODELS) {
                try {
                    await ai.models.generateContent({ model: model, contents: "Hello" });
                    localStorage.setItem('GEMINI_ACTIVE_MODEL', model);
                    return true;
                } catch (e) {
                    lastError = e;
                    const msg = e.message || "";
                    if (msg.includes("400") || msg.includes("INVALID_ARGUMENT") || msg.includes("API_KEY_INVALID") || msg.includes("403")) throw e;
                }
            }
            throw lastError;
        };

        const extractDataFromMedia = async (base64Data, mimeType, role) => {
            const ai = getAIClient();
            const modelName = getActiveModel();
            const prompt = role === TeacherRole.SUBJECT 
                ? `B·∫°n l√† tr·ª£ l√Ω nh·∫≠p li·ªáu. H√£y ph√¢n t√≠ch h√¨nh ·∫£nh/PDF b·∫£ng ƒëi·ªÉm n√†y:
                1. T√åM T√äN M√îN H·ªåC: ƒê·ªçc k·ªπ ti√™u ƒë·ªÅ b·∫£ng.
                2. TR√çCH XU·∫§T DANH S√ÅCH H·ªåC SINH:
                - C·ªôt h·ªç t√™n: L·∫•y ƒë·∫ßy ƒë·ªß.
                - C·ªôt ƒëi·ªÉm: T√¨m c·ªôt ƒëi·ªÉm t·ªïng k·∫øt cu·ªëi c√πng.
                - C·ªôt x·∫øp lo·∫°i: T√¨m c·ªôt x·∫øp lo·∫°i ho·∫∑c ƒê/Cƒê.
                - Ch·ªâ l·∫•y d√≤ng ch·ª©a th√¥ng tin h·ªçc sinh.`
                : `B·∫°n l√† tr·ª£ l√Ω nh·∫≠p li·ªáu. Tr√≠ch xu·∫•t b·∫£ng t·ªïng k·∫øt:
                - H·ªç t√™n.
                - K·∫øt qu·∫£ h·ªçc t·∫≠p (KQHT).
                - K·∫øt qu·∫£ r√®n luy·ªán (KQRL).
                - S·ªë ng√†y ngh·ªâ.`;

            const responseSchema = {
                type: Type.OBJECT,
                properties: {
                    subjectName: { type: Type.STRING, nullable: true },
                    students: {
                        type: Type.ARRAY,
                        items: {
                            type: Type.OBJECT,
                            properties: {
                                name: { type: Type.STRING },
                                score: { type: Type.NUMBER, nullable: true },
                                rating: { type: Type.STRING, nullable: true },
                                kqht: { type: Type.STRING, nullable: true },
                                kqrl: { type: Type.STRING, nullable: true },
                                absences: { type: Type.NUMBER, nullable: true }
                            },
                            required: ["name"]
                        }
                    }
                },
                required: ["students"]
            };

            return callWithRetry(async () => {
                const response = await ai.models.generateContent({
                    model: modelName,
                    contents: { parts: [{ inlineData: { mimeType, data: base64Data } }, { text: prompt }] },
                    config: { responseMimeType: "application/json", responseSchema: responseSchema }
                });
                
                let rawData;
                try { rawData = JSON.parse(response.text); } catch (e) {
                    try { rawData = JSON.parse(response.text.replace(/```json/g, '').replace(/```/g, '').trim()); } catch (e2) { return { students: [] }; }
                }

                const studentsList = rawData.students || (Array.isArray(rawData) ? rawData : []);
                const students = studentsList.map((item, idx) => ({
                    id: `student-img-${Date.now()}-${idx}`,
                    name: item.name || `H·ªçc sinh ${idx + 1}`,
                    subjectScore: item.score,
                    subjectRating: item.rating,
                    academicResult: item.kqht,
                    conductRating: item.kqrl,
                    absences: item.absences,
                    comment: '',
                    isProcessing: false
                }));
                
                const normalizeSubjectName = (rawName) => {
                    if (!rawName) return undefined;
                    const s = rawName.toLowerCase();
                    if (s.includes('to√°n')) return 'To√°n';
                    if (s.includes('vƒÉn') || s.includes('vi·ªát')) return 'VƒÉn';
                    if (s.includes('khtn') || s.includes('l√Ω') || s.includes('h√≥a') || s.includes('sinh')) return 'KHTN';
                    if (s.includes('ls') || s.includes('s·ª≠') || s.includes('ƒë·ªãa')) return 'LS & ƒêL';
                    if (s.includes('tin')) return 'Tin h·ªçc';
                    if (s.includes('anh')) return 'Ng.ng·ªØ';
                    if (s.includes('gdcd')) return 'GDCD';
                    if (s.includes('c√¥ng ngh·ªá')) return 'C.ngh·ªá';
                    if (s.includes('th·ªÉ')) return 'GDTC';
                    if (s.includes('nh·∫°c') || s.includes('m·ªπ')) return 'Ngh·ªá thu·∫≠t';
                    return undefined;
                };

                return { students, detectedSubject: normalizeSubjectName(rawData.subjectName) };
            });
        };

        const generateCommentsBatch = async (students, role, subjectName = "M√¥n h·ªçc") => {
            if (students.length === 0) return new Map();
            const ai = getAIClient();
            const modelName = getActiveModel();
            
            let logicRules = "", roleInstruction = "";
            const wordLimit = role === TeacherRole.SUBJECT ? 12 : 20;

            if (role === TeacherRole.SUBJECT) {
                roleInstruction = `B·∫°n l√† Gi√°o vi√™n b·ªô m√¥n d·∫°y m√¥n ${subjectName}.`;
                logicRules = `ƒêi·ªÉm Gi·ªèi (>= 8.0) ho·∫∑c ƒê·∫°t T·ªët: Khen ng·ª£i nƒÉng l·ª±c ƒë·∫∑c th√π. ƒêi·ªÉm Kh√°: Ghi nh·∫≠n c·ªë g·∫Øng. ƒêi·ªÉm TB: Nh·∫Øc nh·ªü chƒÉm ch·ªâ. Y·∫øu/K√©m: Nh·∫Øc √¥n t·∫≠p.`;
            } else {
                roleInstruction = `B·∫°n l√† Gi√°o vi√™n ch·ªß nhi·ªám l·ªõp.`;
                logicRules = `T·ªët/To√†n di·ªán: Khen ng·ª£i. Kh√°: Ghi nh·∫≠n ph·∫•n ƒë·∫•u. C·∫ßn c·ªë g·∫Øng: Khuy√™n c·∫£i thi·ªán. Chuy√™n c·∫ßn: Nh·∫Øc n·∫øu ngh·ªâ nhi·ªÅu.`;
            }

            const systemInstruction = `${roleInstruction} Vi·∫øt nh·∫≠n x√©t ng·∫Øn g·ªçn cho h·ªçc b·∫°. KH√îNG QU√Å ${wordLimit} t·ª´. VƒÉn phong s∆∞ ph·∫°m. ${logicRules}`;
            const outputSchema = {
                type: Type.ARRAY,
                items: {
                    type: Type.OBJECT,
                    properties: { id: { type: Type.STRING }, comment: { type: Type.STRING } },
                    required: ["id", "comment"]
                }
            };

            const studentPayload = students.map(s => role === TeacherRole.SUBJECT 
                ? { id: s.id, name: s.name, score: s.subjectScore !== undefined ? s.subjectScore : s.subjectRating }
                : { id: s.id, name: s.name, kqht: s.academicResult, kqrl: s.conductRating, absences: s.absences }
            );

            return callWithRetry(async () => {
                const response = await ai.models.generateContent({
                    model: modelName,
                    contents: JSON.stringify(studentPayload),
                    config: {
                        systemInstruction: systemInstruction,
                        responseMimeType: "application/json",
                        responseSchema: outputSchema,
                        safetySettings: [
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                        ]
                    },
                });

                let parsedResults;
                try { parsedResults = JSON.parse(response.text); } catch {
                    try {
                        let jsonStr = response.text.replace(/```json/g, '').replace(/```/g, '').trim();
                        const firstBracket = jsonStr.indexOf('[');
                        const lastBracket = jsonStr.lastIndexOf(']');
                        if (firstBracket !== -1 && lastBracket !== -1) jsonStr = jsonStr.substring(firstBracket, lastBracket + 1);
                        parsedResults = JSON.parse(jsonStr);
                    } catch (e) { return new Map(); }
                }
                
                const commentMap = new Map();
                if (Array.isArray(parsedResults)) {
                    parsedResults.forEach(item => { if (item && item.id && item.comment) commentMap.set(item.id, item.comment); });
                }
                return commentMap;
            });
        };

        // --- 3. COMPONENTS ---

        // API KEY MODAL
        const ApiKeyModal = ({ onSave, onClear, hasKey = false }) => {
            const [inputKey, setInputKey] = useState("");
            const [isChecking, setIsChecking] = useState(false);
            const [status, setStatus] = useState('none');
            const [statusMsg, setStatusMsg] = useState("");
            
            const handleCheckAndSave = async () => {
                const cleanKey = inputKey.trim();
                if (!cleanKey) return;
                setIsChecking(true); setStatus('none');
                try {
                    await testApiConnection(cleanKey);
                    setStatus('success');
                    setTimeout(() => onSave(cleanKey), 1000);
                } catch (err) {
                    setStatus('error');
                    let msg = err.message || "";
                    if (msg.includes('404')) setStatusMsg("L·ªói 404: Key ch∆∞a k√≠ch ho·∫°t ho·∫∑c sai.");
                    else if (msg.includes('429')) setStatusMsg("L·ªói 429: Server b·∫≠n.");
                    else setStatusMsg("Key kh√¥ng h·ª£p l·ªá.");
                } finally { setIsChecking(false); }
            };

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/80 backdrop-blur-sm p-4 animate-fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl max-w-lg w-full p-6 relative">
                        <h2 className="text-2xl font-bold text-center text-slate-800 mb-4">C·∫•u h√¨nh API Key</h2>
                        <div className="bg-slate-50 p-4 rounded-lg border border-slate-200 text-sm text-slate-700 mb-4">
                            <p className="font-bold">C√°ch l·∫•y Key mi·ªÖn ph√≠:</p>
                            <p>1. Truy c·∫≠p <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-600 underline">Google AI Studio</a>.</p>
                            <p>2. Ch·ªçn "Create API key".</p>
                        </div>
                        <input type="password" value={inputKey} onChange={(e) => setInputKey(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && handleCheckAndSave()} placeholder="D√°n Key v√†o ƒë√¢y (AIza...)" className="w-full px-4 py-3 rounded-lg border border-slate-300 mb-2 font-mono"/>
                        {status === 'error' && <p className="text-red-600 text-xs mb-2">{statusMsg}</p>}
                        {status === 'success' && <p className="text-green-600 text-xs mb-2">‚úÖ Key h·ª£p l·ªá!</p>}
                        <button onClick={handleCheckAndSave} disabled={isChecking} className={`w-full py-3 text-white font-bold rounded-lg ${status === 'success' ? 'bg-green-600' : 'bg-primary'}`}>{isChecking ? 'ƒêang ki·ªÉm tra...' : 'B·∫Øt ƒë·∫ßu'}</button>
                        {hasKey && onClear && <button onClick={onClear} className="w-full mt-2 text-red-600 text-sm">X√≥a Key c≈©</button>}
                    </div>
                </div>
            );
        };

        // STUDENT LIST
        const StudentList = ({ students, role, subjectName, onUpdateStudent, onRegenerateSingle, onRegenerateAll, onChangeSubject, onDeleteStudent, isGenerating }) => {
            const tableRef = useRef(null);
            const [colWidths, setColWidths] = useState({ stt: 50, name: 200, result: 150, comment: 400, action: 120 });
            
            const getStatusColor = (score, rating, kqht) => {
                if (score !== undefined) return score >= 8 ? 'text-green-600 font-bold bg-green-50' : score < 5 ? 'text-red-500 font-bold bg-red-50' : 'text-slate-700 font-semibold';
                const r = (rating || kqht || '').toLowerCase();
                return (r.includes('t·ªët') || r === 't') ? 'text-green-600 font-bold bg-green-50' : (r.includes('ch∆∞a') || r === 'cƒë') ? 'text-red-500 font-bold bg-red-50' : 'text-slate-700 font-semibold';
            };

            const exportExcel = () => {
                const ws = XLSX.utils.json_to_sheet(students.map((s, i) => ({
                    STT: i + 1, 'H·ªç v√† t√™n': s.name, 
                    ...(role === TeacherRole.SUBJECT ? { 'ƒêi·ªÉm/ƒêG': s.subjectScore ?? s.subjectRating } : { 'KQHT': s.academicResult, 'KQRL': s.conductRating, 'Ngh·ªâ': s.absences }),
                    'Nh·∫≠n x√©t': s.comment
                })));
                const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, "NhanXet");
                XLSX.writeFile(wb, `NhanXet_${role}.xlsx`);
            };

            const exportPDF = async () => {
                if (!tableRef.current) return;
                const canvas = await html2canvas(tableRef.current, { scale: 2 });
                const pdf = new jsPDF('p', 'mm', 'a4');
                pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, pdf.internal.pageSize.getWidth(), (canvas.height * pdf.internal.pageSize.getWidth()) / canvas.width);
                pdf.save(`NhanXet.pdf`);
            };

            const SUBJECTS = ["To√°n", "VƒÉn", "LS & ƒêL", "KHTN", "Tin h·ªçc", "Ng.ng·ªØ", "GDCD", "C.ngh·ªá", "GDTC", "Ngh·ªá thu·∫≠t", "NDGDCƒêP", "HƒêTN&HN", "Kh√°c ..."];

            return (
                <div className="bg-white rounded-2xl shadow-xl border border-slate-200 flex flex-col h-full overflow-hidden animate-fade-in">
                    <div className="p-4 bg-slate-50 border-b flex flex-wrap items-center justify-between gap-4">
                        <div className="flex items-center gap-4">
                            <span className="font-bold text-slate-800 text-lg"><span className="bg-white px-2 py-0.5 rounded border shadow-sm">{students.length}</span> HS</span>
                            {role === TeacherRole.SUBJECT && <select value={subjectName} onChange={(e) => onChangeSubject(e.target.value)} className="bg-white border rounded px-3 py-1 font-semibold">{SUBJECTS.map(s => <option key={s} value={s}>{s}</option>)}</select>}
                        </div>
                        <div className="flex gap-2">
                            <button onClick={onRegenerateAll} disabled={isGenerating} className={`px-4 py-2 bg-blue-600 text-white rounded font-bold ${isGenerating ? 'opacity-70' : ''}`}>{isGenerating ? 'ƒêang t·∫°o...' : 'T·∫°o l·∫°i h·∫øt'}</button>
                            <button onClick={exportExcel} className="px-3 py-2 bg-white border rounded text-green-600 font-bold">Excel</button>
                            <button onClick={exportPDF} className="px-3 py-2 bg-white border rounded text-red-600 font-bold">PDF</button>
                        </div>
                    </div>
                    <div className="overflow-auto flex-1 p-4" ref={tableRef}>
                        <table className="w-full text-left border-collapse border border-slate-200 rounded-lg">
                            <thead className="bg-slate-50 text-slate-700 text-xs font-bold uppercase sticky top-0 z-10">
                                <tr>
                                    <th className="p-4 border" style={{width: colWidths.stt}}>STT</th>
                                    <th className="p-4 border" style={{width: colWidths.name}}>H·ªç T√™n</th>
                                    <th className="p-4 border" style={{width: colWidths.result}}>K·∫øt qu·∫£</th>
                                    <th className="p-4 border" style={{width: colWidths.comment}}>Nh·∫≠n x√©t</th>
                                    <th className="p-4 border text-center" style={{width: colWidths.action}} data-html2canvas-ignore="true">T√°c v·ª•</th>
                                </tr>
                            </thead>
                            <tbody>
                                {students.map((s, i) => (
                                    <tr key={s.id} className="hover:bg-blue-50">
                                        <td className="p-3 text-center border text-slate-500">{i + 1}</td>
                                        <td className="p-3 font-semibold border">{s.name}</td>
                                        <td className="p-3 border text-sm">
                                            {role === TeacherRole.SUBJECT 
                                                ? <span className={`px-2 py-0.5 rounded ${getStatusColor(s.subjectScore, s.subjectRating)}`}>{s.subjectScore ?? s.subjectRating}</span>
                                                : <div className="flex flex-col"><span className={getStatusColor(undefined, undefined, s.academicResult)}>HT: {s.academicResult}</span><span>RL: {s.conductRating}</span>{s.absences ? <span className="text-red-500">Ngh·ªâ: {s.absences}</span> : null}</div>
                                            }
                                        </td>
                                        <td className="p-2 border relative group/textarea">
                                            {s.isProcessing ? <div className="animate-pulse h-10 bg-slate-200 rounded"></div> : 
                                            <textarea className="w-full h-full min-h-[44px] bg-transparent resize-none outline-none" value={s.comment} onChange={(e) => onUpdateStudent(s.id, {comment: e.target.value})} placeholder="Ch∆∞a c√≥ nh·∫≠n x√©t..."></textarea>}
                                        </td>
                                        <td className="p-2 border text-center" data-html2canvas-ignore="true">
                                            <div className="flex justify-center gap-2">
                                                <button onClick={() => onRegenerateSingle(s)} className="text-blue-600 hover:bg-blue-100 p-1 rounded" title="Vi·∫øt l·∫°i">‚Ü∫</button>
                                                <button onClick={() => onDeleteStudent(s.id)} className="text-red-500 hover:bg-red-100 p-1 rounded" title="X√≥a">‚úï</button>
                                            </div>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        // --- 4. MAIN APP ---
        function App() {
            const [role, setRole] = useState(TeacherRole.SUBJECT);
            const [students, setStudents] = useState([]);
            const [subjectName, setSubjectName] = useState('To√°n');
            const [isGenerating, setIsGenerating] = useState(false);
            const [isExtracting, setIsExtracting] = useState(false);
            const [errorMsg, setErrorMsg] = useState(null);
            const [statusMsg, setStatusMsg] = useState(""); 
            const [showKeyModal, setShowKeyModal] = useState(false);
            const [showAbout, setShowAbout] = useState(false);
            const fileInputRef = useRef(null);

            useEffect(() => { if (!getStoredKey()) setShowKeyModal(true); }, []);

            const handleSaveKey = (key) => { localStorage.setItem('GEMINI_API_KEY', key); setShowKeyModal(false); setErrorMsg(null); };
            const handleClearKey = () => { localStorage.removeItem('GEMINI_API_KEY'); setShowKeyModal(true); };

            const updateStudent = (id, updates) => setStudents(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
            const deleteStudent = (id) => setStudents(prev => prev.filter(s => s.id !== id));

            const executeGeneration = async (targetStudents, currentSubject) => {
                if (targetStudents.length === 0) return;
                setIsGenerating(true); setErrorMsg(null); setStatusMsg("ƒêang chu·∫©n b·ªã...");
                setStudents(prev => prev.map(s => ({ ...s, isProcessing: true })));

                try {
                    const chunkSize = 5;
                    for (let i = 0; i < targetStudents.length; i += chunkSize) {
                        const chunk = targetStudents.slice(i, i + chunkSize);
                        const progress = Math.round((i / targetStudents.length) * 100);
                        setStatusMsg(`ƒêang x·ª≠ l√Ω ${i+1}-${Math.min(i+chunkSize, targetStudents.length)} (${progress}%)...`);
                        
                        const commentsMap = await generateCommentsBatch(chunk, role, currentSubject);
                        setStudents(prev => prev.map(s => {
                            if (commentsMap.has(s.id)) return { ...s, comment: commentsMap.get(s.id), isProcessing: false };
                            if (chunk.find(c => c.id === s.id)) return { ...s, isProcessing: false };
                            return s;
                        }));

                        if (i + chunkSize < targetStudents.length) {
                            for (let t = 4; t > 0; t--) { setStatusMsg(`‚è≥ ƒêang "ngh·ªâ" ${t}s... (${progress}%)`); await new Promise(r => setTimeout(r, 1000)); }
                        }
                    }
                    setStatusMsg("");
                } catch (err) {
                    if (err.message === "MISSING_API_KEY") { setShowKeyModal(true); setErrorMsg("Thi·∫øu API Key."); }
                    else if (err.message.includes("429")) setErrorMsg("‚ö†Ô∏è H·∫øt l∆∞·ª£t s·ª≠ d·ª•ng, vui l√≤ng ƒë·ª£i.");
                    else setErrorMsg("L·ªói AI: " + err.message);
                    setStudents(prev => prev.map(s => ({ ...s, isProcessing: false })));
                } finally { setIsGenerating(false); }
            };

            const processFile = async (file) => {
                setErrorMsg(null); setStudents([]);
                let newStudents = [], detectedSub = undefined;
                if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                    const data = await file.arrayBuffer();
                    const res = parseExcelData(data, role);
                    newStudents = res.students; detectedSub = res.detectedSubject;
                    if (newStudents.length === 0) setErrorMsg("File Excel kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá.");
                } else if (file.type.startsWith('image/') || file.type === 'application/pdf') {
                    setIsExtracting(true);
                    try {
                        const reader = new FileReader();
                        await new Promise((resolve) => {
                            reader.onloadend = async () => {
                                try {
                                    const res = await extractDataFromMedia(reader.result.split(',')[1], file.type, role);
                                    newStudents = res.students; detectedSub = res.detectedSubject;
                                    if (newStudents.length === 0) setErrorMsg("Kh√¥ng t√¨m th·∫•y th√¥ng tin HS trong ·∫£nh.");
                                } catch (e) { setErrorMsg(e.message); }
                                resolve();
                            };
                            reader.readAsDataURL(file);
                        });
                    } finally { setIsExtracting(false); }
                }
                if (newStudents.length > 0) {
                    setStudents(newStudents);
                    const sub = detectedSub || subjectName;
                    if (detectedSub) setSubjectName(detectedSub);
                    executeGeneration(newStudents, sub);
                }
            };

            const handleRegenerateSingle = async (s) => {
                updateStudent(s.id, { isProcessing: true });
                try {
                    const map = await generateCommentsBatch([s], role, subjectName);
                    updateStudent(s.id, { comment: map.get(s.id) || "", isProcessing: false });
                } catch (e) { updateStudent(s.id, { isProcessing: false }); }
            };

            return (
                <div className="min-h-screen flex flex-col font-sans bg-slate-50 relative selection:bg-blue-100">
                    <header className="bg-white/80 backdrop-blur-md border-b sticky top-0 z-30 shadow-sm h-16 flex items-center justify-between px-6">
                        <div className="flex items-center gap-3">
                            <div className="w-9 h-9 bg-blue-600 text-white rounded flex items-center justify-center font-bold">AI</div>
                            <h1 className="text-xl font-bold text-slate-800">Tr·ª£ l√Ω Nh·∫≠n x√©t H·ªçc b·∫°</h1>
                        </div>
                        <div className="flex items-center gap-4">
                            <div className="bg-slate-100 p-1 rounded-lg flex">
                                <button onClick={() => { setRole(TeacherRole.SUBJECT); setStudents([]); }} className={`px-4 py-1.5 rounded-md text-sm font-bold ${role === TeacherRole.SUBJECT ? 'bg-white text-blue-700 shadow-sm' : 'text-slate-500'}`}>GV B·ªô m√¥n</button>
                                <button onClick={() => { setRole(TeacherRole.HOMEROOM); setStudents([]); }} className={`px-4 py-1.5 rounded-md text-sm font-bold ${role === TeacherRole.HOMEROOM ? 'bg-white text-blue-700 shadow-sm' : 'text-slate-500'}`}>GV Ch·ªß nhi·ªám</button>
                            </div>
                            <button onClick={() => setShowKeyModal(true)} className="text-slate-400 hover:text-yellow-600 font-bold text-xl" title="C√†i ƒë·∫∑t Key">üîë</button>
                            <button onClick={() => setShowAbout(true)} className="text-slate-400 hover:text-blue-600 font-bold text-xl" title="Th√¥ng tin">‚ìò</button>
                        </div>
                    </header>
                    <main className="flex-1 max-w-7xl w-full mx-auto px-6 py-8 flex flex-col gap-6">
                        {isGenerating && statusMsg && <div className="bg-blue-50 border border-blue-200 text-blue-700 px-4 py-3 rounded-lg flex items-center justify-between animate-fade-in"><span className="font-bold flex items-center gap-2"><span className="animate-spin">‚è≥</span> {statusMsg}</span><span className="text-xs bg-white px-2 py-1 rounded border">Safe Mode</span></div>}
                        
                        {students.length === 0 && (
                            <section className="bg-white rounded-2xl shadow-xl border p-8 animate-fade-in-up text-center">
                                <h2 className="text-xl font-bold mb-6">Nh·∫≠p d·ªØ li·ªáu h·ªçc sinh</h2>
                                <label className={`flex flex-col items-center justify-center w-full h-64 border-2 border-dashed rounded-2xl cursor-pointer transition-all ${isExtracting ? 'bg-blue-50 border-blue-400' : 'hover:bg-slate-50 border-slate-300'}`}>
                                    {isExtracting ? <div className="flex flex-col items-center"><div className="w-12 h-12 border-4 border-blue-600 border-t-transparent rounded-full animate-spin mb-4"></div><p className="font-bold text-blue-700">ƒêang ƒë·ªçc ·∫£nh b·∫£ng ƒëi·ªÉm...</p></div> : 
                                    <>
                                        <div className="text-6xl mb-4">üìÇ</div>
                                        <p className="font-bold text-lg text-slate-700">K√©o th·∫£ file Excel, PDF ho·∫∑c ·∫¢nh v√†o ƒë√¢y</p>
                                        <p className="text-slate-500 mt-2">H·ªó tr·ª£ t·ªët nh·∫•t cho file Excel m·∫´u nh√† tr∆∞·ªùng</p>
                                    </>}
                                    <input ref={fileInputRef} type="file" accept=".xlsx,.xls,.pdf,image/*" className="hidden" onChange={(e) => processFile(e.target.files[0])} disabled={isExtracting}/>
                                </label>
                                {errorMsg && <div className="mt-4 p-3 bg-red-50 text-red-600 rounded font-bold border border-red-200">{errorMsg}</div>}
                            </section>
                        )}
                        
                        {students.length > 0 && <StudentList students={students} role={role} subjectName={subjectName} onUpdateStudent={updateStudent} onRegenerateSingle={handleRegenerateSingle} onRegenerateAll={() => executeGeneration(students, subjectName)} onChangeSubject={setSubjectName} onDeleteStudent={deleteStudent} isGenerating={isGenerating} />}
                    </main>
                    {showKeyModal && <ApiKeyModal onSave={handleSaveKey} onClear={handleClearKey} hasKey={!!getStoredKey()} />}
                    {showAbout && <div className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 p-4"><div className="bg-white rounded-xl p-6 max-w-sm w-full"><h3 className="font-bold text-xl mb-4">Th√¥ng tin</h3><p className="text-slate-600 mb-4">·ª®ng d·ª•ng h·ªó tr·ª£ vi·∫øt nh·∫≠n x√©t h·ªçc b·∫° theo TT22.<br/>T√°c gi·∫£: Nguy·ªÖn Ch√≠ D≈©ng.<br/>ƒê∆°n v·ªã: THCS ƒêo√†n B·∫£o ƒê·ª©c.</p><button onClick={() => setShowAbout(false)} className="w-full py-2 bg-slate-800 text-white rounded-lg font-bold">ƒê√≥ng</button></div></div>}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>